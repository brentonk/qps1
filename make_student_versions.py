#!/usr/bin/env python3
"""
Convert a Quarto (.qmd) file to a standalone renderable version.

This script:
1. Comments out all images not generated by code chunks (markdown image syntax)
2. Removes .aside blocks (which render poorly in PDF)
3. Creates a YAML header with the chapter name as title and PDF output with 12pt fontsize
4. Removes the initial header with the chapter name
5. Promotes all further markdown headlines by one level (e.g., ## becomes #)
"""

import sys
import re
import argparse
from pathlib import Path
import glob
import os


def extract_chapter_title(content):
    """Extract the chapter title from the first header line."""
    lines = content.split('\n')
    for line in lines:
        if line.startswith('# '):
            # Extract title, removing any {#sec-...} reference
            title = re.sub(r'\s*\{#.*\}', '', line[2:]).strip()
            return title
    return "Untitled Chapter"


def comment_out_images(content):
    """Comment out markdown image syntax that are not in code chunks."""
    lines = content.split('\n')
    result_lines = []
    in_code_chunk = False
    
    for line in lines:
        # Check if we're entering or leaving a code chunk
        if line.startswith('```'):
            in_code_chunk = not in_code_chunk
            result_lines.append(line)
            continue
            
        # If we're not in a code chunk and line contains markdown image syntax
        if not in_code_chunk and re.search(r'!\[.*?\]\(.*?\)', line):
            # Comment out the line
            result_lines.append('<!-- ' + line + ' -->')
        else:
            result_lines.append(line)
    
    return '\n'.join(result_lines)


def remove_aside_blocks(content):
    """Remove .aside blocks from Quarto content."""
    # Pattern to match .aside blocks with their content
    # Matches from ::: {.aside} to the closing :::
    aside_pattern = r':::\s*\{\.aside\}.*?:::\s*(?:\n|$)'
    
    # Remove aside blocks (multiline, case insensitive)
    content = re.sub(aside_pattern, '', content, flags=re.DOTALL | re.MULTILINE)
    
    # Clean up multiple consecutive newlines that might be left behind
    content = re.sub(r'\n\n\n+', '\n\n', content)
    
    return content


def remove_first_header_and_promote_others(content):
    """Remove the first header and promote all other headers by one level."""
    lines = content.split('\n')
    result_lines = []
    found_first_header = False
    
    for line in lines:
        # Skip the first header line
        if not found_first_header and line.startswith('# '):
            found_first_header = True
            continue
            
        # Promote headers by one level (remove one #)
        if line.startswith('#'):
            # Count leading #s
            hash_count = len(line) - len(line.lstrip('#'))
            if hash_count > 1:
                # Remove one # to promote the header
                promoted_line = line[1:]
                result_lines.append(promoted_line)
            else:
                # This is already an h1, keep as is
                result_lines.append(line)
        else:
            result_lines.append(line)
    
    return '\n'.join(result_lines)


def create_yaml_header(title):
    """Create a YAML header with title and PDF output configuration."""
    yaml_header = f"""---
title: "{title}"
format:
  pdf:
    fontsize: 12pt
---

"""
    return yaml_header


def process_qmd_file(file_path):
    """Process a QMD file and return the standalone version."""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
    except FileNotFoundError:
        print(f"Error: File '{file_path}' not found.", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error reading file: {e}", file=sys.stderr)
        sys.exit(1)
    
    # Extract chapter title
    title = extract_chapter_title(content)
    
    # Comment out images
    content = comment_out_images(content)
    
    # Remove .aside blocks
    content = remove_aside_blocks(content)
    
    # Remove first header and promote others
    content = remove_first_header_and_promote_others(content)
    
    # Create YAML header
    yaml_header = create_yaml_header(title)
    
    # Combine everything
    standalone_content = yaml_header + content
    
    return standalone_content


def process_all_qmd_files():
    """Process all .qmd files in the current directory except excluded ones."""
    # Files to exclude
    excluded_files = {'data_sources.qmd', 'index.qmd', 'references.qmd'}
    
    # Find all .qmd files in current directory
    qmd_files = glob.glob('*.qmd')
    
    # Filter out excluded files and syllabus files
    files_to_process = [
        f for f in qmd_files 
        if f not in excluded_files and not f.startswith('syllabus_')
    ]
    
    if not files_to_process:
        print("No .qmd files found to process.", file=sys.stderr)
        return
    
    # Create student_versions directory if it doesn't exist
    output_dir = Path('student_versions')
    output_dir.mkdir(exist_ok=True)
    
    print(f"Processing {len(files_to_process)} files...")
    
    for file_path in files_to_process:
        print(f"Processing: {file_path}")
        try:
            standalone_content = process_qmd_file(file_path)
            
            # Write to student_versions directory with same filename
            output_path = output_dir / file_path
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(standalone_content)
            
            print(f"  → Created: {output_path}")
            
        except Exception as e:
            print(f"  → Error processing {file_path}: {e}", file=sys.stderr)
    
    print("Done!")


def main():
    parser = argparse.ArgumentParser(description='Convert QMD files to standalone renderable versions')
    parser.add_argument('file', nargs='?', help='Path to a specific QMD file to process (optional)')
    
    args = parser.parse_args()
    
    if args.file:
        # Process single file (original behavior)
        file_path = Path(args.file)
        if not file_path.exists():
            print(f"Error: File '{file_path}' does not exist.", file=sys.stderr)
            sys.exit(1)
        
        if not file_path.suffix.lower() == '.qmd':
            print(f"Warning: File '{file_path}' does not have .qmd extension.", file=sys.stderr)
        
        standalone_content = process_qmd_file(file_path)
        print(standalone_content)
    else:
        # Process all files (new behavior)
        process_all_qmd_files()


if __name__ == '__main__':
    main()